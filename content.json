{"meta":{"title":"Allencatの博客","subtitle":"一个小孩闲来无事的尝试","description":"","author":"Allencat","url":"http://example.com","root":"/"},"pages":[{"title":"about","date":"2025-01-08T04:17:35.000Z","updated":"2025-01-08T09:52:55.477Z","comments":false,"path":"about/index-1.html","permalink":"http://example.com/about/index-1.html","excerpt":"","text":""},{"title":"about","date":"2025-01-07T08:12:28.000Z","updated":"2025-01-08T10:13:17.204Z","comments":true,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":"学生党一枚"},{"title":"archives","date":"2025-01-07T08:12:09.000Z","updated":"2025-01-07T08:12:09.892Z","comments":true,"path":"archives/index.html","permalink":"http://example.com/archives/index.html","excerpt":"","text":""},{"title":"categories","date":"2025-01-08T04:16:28.000Z","updated":"2025-01-08T09:52:54.737Z","comments":false,"path":"categories/index-1.html","permalink":"http://example.com/categories/index-1.html","excerpt":"","text":""},{"title":"分类","date":"2025-01-07T08:09:36.000Z","updated":"2025-01-08T10:13:43.400Z","comments":false,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"friends","date":"2025-01-08T04:17:18.000Z","updated":"2025-01-08T04:17:18.404Z","comments":true,"path":"friends/index.html","permalink":"http://example.com/friends/index.html","excerpt":"","text":""},{"title":"标签","date":"2025-01-07T07:20:11.000Z","updated":"2025-01-08T09:52:54.037Z","comments":false,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"git学习","slug":"git","date":"2025-01-08T08:17:55.000Z","updated":"2025-01-08T08:19:49.232Z","comments":false,"path":"2025/01/08/git/","permalink":"http://example.com/2025/01/08/git/","excerpt":"","text":"git是什么Git 是一个免费的、开源的分布式版本控制系统，可以快速高效地处理从小型到大型的各种项目。 版本控制：可以记录文件修改历史记录，从而让用户能够查看历史版本，方便版本切换。 分布式：![[Pasted image 20240317203212.png|300]]首先，分布式版本控制系统根本没有“中央服务器”，每个人的电脑上都是一个完整的版本库，这 样，你工作的时候，就不需要联网了，因为版本库就在你自己的电脑上。既然每个人电脑上都有一 个完整的版本库，那多个人如何协作呢？比方说你在自己电脑上改了文件A，你的同事也在他的电脑 上改了文件A，这时，你们俩之间只需把各自的修改推送给对方，就可以互相看到对方的修改了。 集中式： ![[Pasted image 20240317200249.png|300]]版本库是集中存放在中央服务器的，而干活的时候，用的都是自己的电脑，所以要先从中央服务器 取得最新的版本，然后开始干活，干完活了，再把自己的活推送给中央服务器。CVS CVS 作为最早的开源而且免费的集中式版本控制系统，直到现在还有不少人在用。但由于 CVS 自身设计的问题，会造成提交文件不完整，版本库莫名其妙损坏的情况。 SVN 同样是开源而且免费的 SVN 修正了 CVS 的一些稳定性问题，是目前用得最多的集中式版本库控制系统。原文链接：https://blog.csdn.net/qq_40395874/article/details/116486027 中央服务器就好比是一个图书馆，你要改一本书，必须先从图书馆借出来，然后回到家自己改， 改完了，再放回图书馆。 弊端： 必须联网才能工作，如果在局域网内还好，带宽够大，速度够快，可如果在互联网上，遇到网速慢的话，可能提交一个10M的文件就需要5分钟 为什么要用版本控制工具 实际项目开发中，总是需要将源码拷贝多份，以满足不同的需求。例如，每发布一个版本，就需要复制一份来存档当前版本的源码。 实际项目开发中，基本都是多个人合作完成，在多个人写代码时，就牵扯到代码合并成一份的问题。 在 Linux 开源的初期，Linux 开源项目的代码是 linus 本人通过 linux 命令 diff 和 patch 两条命令手动完成。随着 Linux 代码越来越壮大，靠 Linus 一个人来手动合并已经不现实。 2002 年，Linus 选择了一个商业版本控制系统 BitKeeper 作为 Linux 内核的代码管理工具（BitKeeper 的开发商 BitMover 授权 linux 社区免费使用）。但是，免费使用是有很多的限制的，因此 linux 社区的大佬开始破解 BitKeeper。其中，samba 的作者 andrew 破解成功了。但是被 BitMover 公司发现，收回免费使用权。迫不得已，Linus 选择了自己开发一个分布式版本控制工具以替代 BitKeeper。传说，Linus 闭关一个月，写出了 Git。此后，Git 成功接管了 Linux 社区的版本控制工作 工作机制![[Pasted image 20240317195056.png|600]] 什么是github?GitHub是一个面向开源及私有软件项目的托管平台，提供了一些社交网络功能，主要为程序员服务。在GitHub上可以发布开源软件、协作编程、管理项目、代码审查、免费托管维基、下载代码等。 Git偏向于版本控制的具体实现，而GitHub则扮演了一个集成了Git的版本控制和社交化代码托管平台的角色。Git可以用于本地代码管理，而GitHub用于与他人的代码协作和分享。简单地说，Git是一种工具，而GitHub是Git的一个应用场景。 开源协议开源协议的主要作用是规定了使用和共享开源软件的方式和条件，从而促进了开源软件的发展和应用。保护开发者和使用者的权益。开源协议允许开发者共享源代码，鼓励协作与开放，促进了开源社区的形成和发展，为开发者提供了资源与支持。并且提高了代码的复用性 六种常用的开源协议：![[Pasted image 20240408111910.png]]https://blog.csdn.net/qq_28877125/article/details/116887370?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522171254540616777224427654%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=171254540616777224427654&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-116887370-null-null.142^v100^pc_search_result_base2&amp;utm_term=%E5%BC%80%E6%BA%90%E5%8D%8F%E8%AE%AE&amp;spm=1018.2226.3001.4187 开源协议和GitHub之间具有较强的关联性。开源协议使得开源软件的共享和授权变得合法和有序，而GitHub则为开源协议的实施提供了便利的存储、分享和交流渠道。 gitlabGitLab 是一个用于仓库管理系统的开源项目，使用Git作为代码管理工具，并在此基础上搭建起来的web服务。 git,github,gitlab之间的区别GitHub和GiLlab两个都是基于Web的Git远程仓库，它们都提供了分享开源项目的平台，为开发团队提供了存储、分享、发布和合作开发项目的中心化云存储的场所。gitlab的私密性更好。 ![[Pasted image 20240408131325.png]] git kraken: Git 可视化工具如何安装以及配置环境：https://blog.csdn.net/Ckuanfeng/article/details/127560434如何使用：https://blog.csdn.net/shaobing32/article/details/132314377 正式使用开始学习githttps://blog.csdn.net/weixin_47638941/article/details/120632890?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522171264248116800182787480%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=171264248116800182787480&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-120632890-null-null.142^v100^pc_search_result_base2&amp;utm_term=%E5%A6%82%E4%BD%95%E4%B8%8B%E8%BD%BDgit&amp;spm=1018.2226.3001.4187![[Pasted image 20240409060437.png]] 123git config --global user.name &quot;名称&quot;git config --global user.email &quot;邮箱&quot; 如何配置ssh密钥什么是ssh密钥SSH（Secure Shell）密钥是一种用于加密通信和身份验证的安全协议。在SSH协议中，密钥用于验证客户端和服务器之间的身份，并加密在它们之间传输的数据，从而提供了安全性和保密性。 SSH密钥通常由两部分组成：私钥和公钥。 私钥（Private Key）：私钥是一段保密的数据，存储在客户端的本地计算机上。它是由用户创建并保密的，用于对数据进行加密和签名。私钥通常是一个文件，需要妥善保管，不应该泄露给他人。 公钥（Public Key）：公钥是与私钥配对的非保密数据，可以公开发布。公钥用于解密由私钥加密的数据，或验证由私钥签名的数据的真实性。公钥通常是一个文件，可以被传输到需要访问的服务器上。https://www.runoob.com/git/git-remote-repo.html ![[企业微信截图_1712649531867.png]]如果 12ssh -T git@github.com 失败则https://blog.csdn.net/qq_52293358/article/details/124535927 检查已有的配置环境 1git config --list 1git add 将文件添加到Git的暂存区，准备将其纳入下一次提交。可以指定具体的文件名或使用 . 来添加当前目录下的所有文件 1git status 显示当前仓库的状态，包括已修改但未暂存的文件、已暂存但未提交的文件以及分支信息提供了对当前仓库中文件变更的概览 1git diff 显示当前工作区与暂存区之间的文件差异 1git log 显示当前分支的提交历史。 1git commit -m &quot;[提交消息]&quot; 提交暂存区的文件到Git仓库，并创建一个新的提交记录。 1git push &lt;远程主机名&gt; &lt;本地分支名&gt;:&lt;远程分支名&gt; https://blog.csdn.net/loongkingwhat/article/details/84378386?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522171265457416777224485607%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=171265457416777224485607&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-84378386-null-null.142^v100^pc_search_result_base2&amp;utm_term=%20git%20push&amp;spm=1018.2226.3001.4187如何push到所需要的仓库 123git remote add origin https://github.com/allencat0712/sncgittry.git git branch -M main git push -u origin main ![[Pasted image 20240409195346.png]]","categories":[{"name":"git","slug":"git","permalink":"http://example.com/categories/git/"}],"tags":[{"name":"git","slug":"git","permalink":"http://example.com/tags/git/"}]},{"title":"数据库学习","slug":"数据库学习","date":"2025-01-08T07:15:10.000Z","updated":"2025-01-08T09:52:53.089Z","comments":false,"path":"2025/01/08/数据库学习/","permalink":"http://example.com/2025/01/08/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%A6%E4%B9%A0/","excerpt":"","text":"数据库SQL：DDL查询所有数据库：注意databases 1SHOW DATABASES; 查询当前数据库： 1SELECT DATABASE(); 创建数据库: 1CREATE DATABASE[数据库名][字符集][排列规则]; 如果重复执行时会报错，数据库已经存在就不能重复存在建字符串类型的时候用varchar 后面必须加()注明长度删除数据库： 1DROP DATABASE [数据库名]; 使用数据库：USE 数据库 DDL-表操作-查询查询当前数据库中的所有表： 1SHOW TABLES; 查询表结构： 1DESC 表名; 查询指定表的建表语句 1SHOW CREATE TABLE 表名; DDL-表操作-数据类型数值类型 TINYINT SMALLINT 类似于short INT 0～4294967295 BIGINT 0～2^64-1 FLOAT 单精度浮点数 DOUBLE 双精度浮点数 score double(4,1)表示一个double类型，整体长度是4,小数部分的 长度为1位 DECIMAL文本类型 CHAR 定长字符串 性能高 VARCHAR 变长字符串 性能较差 TEXT 长文本数据 BLOB 二进制形式的长文本数据日期类型 DATE 日期值 TIME 时间值 YEAR 年份 DATETIME 混合日期和时间值 DDL-表操作-修改添加字段： 1ALTER TABLE 表名 字段名 类型（长度）; 修改字段修改数据类型 1ALTER TABLE 表名 MODIFY 字段名 新数据类型; 修改字段名和字段类型 1ALTER TABELE 表名 CHANGE 旧字段名 新字段名 类型; 删除字段： 1ALTER TABLE 表名 DROP 字段名; 修改表名： 1ALTER TABLE 表名 RENAME TO 新表名; 删除指定表，并重新创建，重置该表： 1TRUNCATE TABLE 表名; DML-增-删-改DML-添加数据-insert1INSERT INTO 表名（字段1,字段2）VALUES（值1,值2）; 字段1对应值1,如果要进行多个值同时插入，（）间用,分割。 DML-修改数据-updata1UPDATE 表名 SET 字段名=值1,字段名2=值2,……[WHERE 条件] 条件比如说id&#x3D;1,也就是id为1的数据进行修改 DML删除数据1DELETE FROM 表名 [WHERE 条件] 注意：DELETE中语句的条件可以有也可以没有，如果没有条件，则会删除整张表的所有数据不可以删除某一个字段的值 DQL-数据查询语言关键字-SELECT可以分为以下部分： 1.基础查询1SELECT 字段1, 字段2, 字段3 ... FROM 表名 ; 去除重复记录： 1SELECT DISTINCT 字段列表 FROM 表名; 2.条件查询1SELECT 字段列表 FROM 表名 WHERE 条件列表 ; 比较运算符&lt; &gt; &#x3D; &lt;&#x3D; &gt;&#x3D; !&#x3D; IS NULL LIKE(占位符）逻辑运算符AND OR NOTeg: 1234select * from emp where age between 15 and 20;select * from emp where gender = &#x27;女&#x27; and age &lt; 25;select * from emp where age in(18,20,40);select * from emp where idcard like &#x27;_________________X&#x27;;//查询身份证号最后一位是X的员工信息 3.聚合函数将一列数据作为一个整体，进行纵向计算 1SELECT 聚合函数(字段列表) FROM 表名 ; 常见的聚合函数：count（统计数量） max min avg(平均数） sum 1select max(age) from emp; 4.分组查询1SELECT 字段列表 FROM 表名 [ WHERE 条件 ] GROUP BY 分组字段名 [ HAVING 分组后过滤条件 ]; where与having区别 执行时机不同： where是分组之前进行过滤，不满足where条件，不参与分组；而having是分组 之后对结果进行过滤。 判断条件不同： where不能对聚合函数进行判断，而having可以。 查询年龄小于45的员工 , 并根据工作地址分组 , 获取员工数量大于等于3的工作地址 12select workaddress, count(*) address_count from emp where age &lt; 45 group byworkaddress having address_count &gt;= 3; 5.排序查询-order by1SELECT 字段列表 FROM 表名 ORDER BY 字段1 排序方式1 , 字段2 排序方式2 ; ASC 升序 DESC 降序 12select * from emp order by age asc;select * from emp order by age; 6.分页查询1SELECT 字段列表 FROM 表名 LIMIT 起始索引, 查询记录数 ; eg: 12select * from emp limit 0,10;select * from emp limit 10; 编写顺序select –&gt;字段列表–&gt;from –&gt;表名列表 –&gt;where –&gt;条件列表–&gt;group by–&gt;分组字段列表–&gt; having–&gt;分组后条件列表–&gt;order by –&gt;排序字段列表–&gt;limit –&gt;分页参数 eg: 12345select tmp.t1 person1,tmp.t2 person2,count(*) call_count,sum(tmp.duration) total_durationfrom (select if(from_id&gt;to_id,to_id,from_id) t1,if(from_id&gt;to_id,from_id,to_id) t2,duration from calls) tmpgroup by tmp.t1,tmp.t2 tmp.t1是一个临时的分组，表示的是一列，新表的一列，然而person1是这列的名字，相当于t1是这个新表名叫person1这列的一个指针，指向的是person1这列的内容而if(from_id&gt;to_id,to_id,from_id） 是一个条件的判断，是指如果from_id&gt;to_id,则返回to_id,若为假则返回from_id DCL-数据控制语言可以控制数据库可以由谁访问以及谁可以访问哪些数据库 用户管理权限控制函数字符串函数：Mysql函数大全字符串函数：链接，转换，去除空格，截取等数值函数，日期函数，流程函数 约束目的：保证数据库中数据的正确性，有效性，完整性分类：非空约束 NOT NULL唯一约束： UNIQUE unique主键约束：PRIMARY KEY primary key默认约束：DEFAULT default外键约束：FOREIGN KEY foreign key检查约束：CHECK check可以完成表结构的创建 ：字段名 数据类型 约束关键字外键约束：让两张表之间建立链接，从而保证一致性和完整性，外键是’某个表 A’中的’一列 column’,它包含在’另一个表 B’的’主键’中格式： 1alter table emp add constraint fk_emp_dept_id foreign key (dept_id) reference dept(id); 这条语句的作用是在 emp 表上添加一个名为 fk_emp_dept_id 的外键约束，该外键约束基于 emp 表中的 dept_id 列，并指向 dept 表中的 id 列。 多表关系一对多 在多的表中一列建立外键约束多对多 建立第三张中间表，中间至少包含两个外键，分别关联两方主键一对一 将表拆分为多表，并设置唯一外键 多表查询：需要消除无效的笛卡尔积连接查询：内连接 外连接 1234select sname from s where not exists(select * from scWhere sno=s.sno and cno=&#x27;002&#x27;) 所有不存在这条记录的学生被返回 unique index 唯一索引binary column 1234567891011SUM(score_points) OVER (PARTITION BY gender ORDER BY day) 是 SQL 中窗口函数的用法，它结合了聚合函数和窗口函数的概念。下面是它的作用和用法的分解：语法解析SUM(score_points):是一个聚合函数，用于计算 score_points 列的累积和。OVER 子句:定义了窗口范围，即在哪些数据行上应用聚合函数。PARTITION BY gender:将数据按 gender 列分组（类似于 GROUP BY，但不会减少结果行数）。每个 gender 的分组内分别计算。ORDER BY day:指定窗口内的行按 day 列排序，从而实现有序累加。","categories":[{"name":"数据库","slug":"数据库","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}]},{"title":"Hello World","slug":"hello-world","date":"2025-01-02T09:09:11.980Z","updated":"2025-01-02T09:09:11.981Z","comments":true,"path":"2025/01/02/hello-world/","permalink":"http://example.com/2025/01/02/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[{"name":"git","slug":"git","permalink":"http://example.com/categories/git/"},{"name":"数据库","slug":"数据库","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"git","slug":"git","permalink":"http://example.com/tags/git/"},{"name":"数据库","slug":"数据库","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}]}