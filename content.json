{"meta":{"title":"Allencatの博客","subtitle":"一个小孩闲来无事的尝试","description":"","author":"Allencat","url":"http://example.com","root":"/"},"pages":[{"title":"about","date":"2025-01-08T04:17:35.000Z","updated":"2025-01-08T09:52:55.477Z","comments":false,"path":"about/index-1.html","permalink":"http://example.com/about/index-1.html","excerpt":"","text":""},{"title":"about","date":"2025-01-07T08:12:28.000Z","updated":"2025-01-08T10:25:52.848Z","comments":false,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":"学生党一枚"},{"title":"archives","date":"2025-01-07T08:12:09.000Z","updated":"2025-01-07T08:12:09.892Z","comments":true,"path":"archives/index.html","permalink":"http://example.com/archives/index.html","excerpt":"","text":""},{"title":"categories","date":"2025-01-08T04:16:28.000Z","updated":"2025-01-08T09:52:54.737Z","comments":false,"path":"categories/index-1.html","permalink":"http://example.com/categories/index-1.html","excerpt":"","text":""},{"title":"分类","date":"2025-01-07T08:09:36.000Z","updated":"2025-01-08T10:13:43.400Z","comments":false,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"friends","date":"2025-01-08T04:17:18.000Z","updated":"2025-01-08T04:17:18.404Z","comments":true,"path":"friends/index.html","permalink":"http://example.com/friends/index.html","excerpt":"","text":""},{"title":"标签","date":"2025-01-07T07:20:11.000Z","updated":"2025-01-08T10:28:59.523Z","comments":false,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"机器人操控文献阅读","slug":"机器人操控文献阅读","date":"2025-01-09T03:46:56.000Z","updated":"2025-01-09T08:36:02.947Z","comments":false,"path":"2025/01/09/机器人操控文献阅读/","permalink":"http://example.com/2025/01/09/%E6%9C%BA%E5%99%A8%E4%BA%BA%E6%93%8D%E6%8E%A7%E6%96%87%E7%8C%AE%E9%98%85%E8%AF%BB/","excerpt":"","text":"基于大规模语言模型的机器人操控终身学习框架：背景 机器人操控技能：现有的机器人已经能够掌握一些低层次的操作技能，如拾取和放置物体。过去的研究表明，这些技能可以通过语言模型来进行规划和执行。 大规模语言模型（LLMs）：大规模语言模型，如GPT-4，展示了强大的知识保留和推理能力，这些模型有潜力将高层次任务分解为可学习的技能。 终身学习：终身学习指的是系统能够不断积累和记忆技能，并在需要时重用这些技能，而不是每次都从头开始学习。 解决的问题 任务分解和技能学习：通过使用GPT-4等大规模语言模型，系统能够将复杂的任务分解为具体的子任务，并学习和重用这些子技能。 技能重用和适应：研究发现，通过提供优化的提示，语言模型能够在不同的场景中高效地重用和适应技能。 系统可扩展性和模块化：通过设计一个模块化的系统架构，能够轻松地进行模块替换和扩展，从而支持不同的算法和技能实现。 通过这些方法，论文展示了如何利用大规模语言模型来增强机器人终身学习的能力，并且在广泛的实验中验证了系统的有效性和可扩展性。 VoxPoser：利用语言模型进行机器人操作的可组合3D价值地图目的： VoxPoser旨在通过使用LLMs和视觉语言模型（VLMs）直接在3D观察空间中生成成本和约束，从而摆脱对预定义运动原语的依赖。### 关键步骤：- 问题的形式化：将任务描述为优化问题，其中包括任务成本和控制成本，并考虑到动态和运动学约束。- 语言指令的基础化：利用LLMs将语言指令转化为3D价值图，这些图在机器人观察空间中引导“感兴趣的实体”（如机器人末端执行器）的运动。- 零样本轨迹合成：通过零阶优化方法生成机器人操作轨迹，并在每个步骤重新规划以应对动态干扰。- 在线经验学习：通过在线交互高效学习动态模型，增强系统在接触密集任务中的表现。 目的： 在机器人操作中实现了高度的灵活性和通用性，为处理复杂和多样化的任务提供了一种高效的方法。 通过LLM，用户可以使用自然语言与机器人交互，无需专门的编程技能或复杂的界面操作，这种自然交互方式使得机器人的操作更加直观、简单，降低了使用门槛。相比传统的编程接口或遥控器，语音指令更加直观和高效，能够快速传达用户的意图和要求。同时，LLM的应用使得机器人具备一定的智能化能力，通过结合上下文信息和语义理解，能够更准确地理解用户的指令，并做出相应的反应和决策，这种智能化能力使得机器人更加智能、灵活，能够适应复杂的操作场景。 LLM3: 基于大型语言模型的任务和运动规划与运动失败推理#所需要解决的问题：传统的TAMP方法在处理复杂环境和新任务时表现出不足，特别是在生成动作序列时，难以兼顾符号任务目标和连续运动约束。传统的任务和运动规划（Task and Motion Planning, TAMP）方法依赖于手动设计的接口，这些接口将符号任务规划与连续运动生成连接起来。 LLM可以达到的效果： 论文提出了一种创新的方法，利用预训练的大型语言模型（LLM）的强大推理和规划能力来改进TAMP。 具体来说，LLM3框架通过以下方式工作： 提出符号动作序列以实现任务目标。 生成连续动作参数以确保运动的可行性。 推理运动规划反馈，迭代改进动作序列和参数。 提升TAMP的通用性和效率 通过引入LLM3框架，论文成功地减少了手动设计领域特定模块的需求，使任务和运动规划过程更具通用性。 LLM3框架能够有效地处理现实世界中的新任务和复杂环境，提高了规划成功率和效率。LLM3框架通过利用大型语言模型的强大推理能力和运动规划反馈机制，解决了传统TAMP方法在应对现实世界复杂任务时的局限性，提高了任务和运动规划的通用性和效率。 ManipLLM: 面向对象中心的机器人操控的具身多模态大型语言模型**这篇论文《ManipLLM: Embodied Multimodal Large Language Model for Object-Centric Robotic Manipulation》主要围绕机器人操控的背景和挑战，提出了一种创新的方法来解决这些问题。 背景机器人操控需要准确预测接触点和末端执行器的方向，以确保操作成功。然而，基于学习的机器人操控在模拟器中训练时，通常会面临广泛类别下的泛化问题。这些模型往往难以应对大量不同种类的对象。 方法论文提出了一种利用多模态大型语言模型（MLLMs）的强大推理能力来增强操控稳定性和泛化能力的方法。具体来说，方法包括以下几个关键步骤： 注入适配器并微调： 保留MLLMs的内在常识和推理能力，同时赋予它们操控能力。 训练范式： 训练范式包括对象类别理解、可操作性先验推理和基于对象的姿势预测，以刺激MLLMs在操控中的推理能力。 推理阶段： 使用RGB图像和文本提示，通过思维链预测末端执行器的姿势。 引入主动阻抗适应策略，闭环方式规划下一步路径。 设计测试时适应策略（TTA），使模型更好地适应当前真实场景配置。 解决的问题论文主要解决了以下问题： 泛化性差： 通过利用MLLMs的推理能力，提高操控的稳定性和泛化性。 低层次操作预测的解释性差： 采用思维链推理，使模型的预测过程更加可解释。 训练数据不足： 设计复杂的微调任务，包括对象类别识别、可操作性先验推理和操控姿势预测，使模型能够生成可解释的姿势预测。 真实世界和模拟环境的差距： 设计了测试时适应策略（TTA），通过在推理过程中调整部分模型参数，使模型在真实世界中的表现更好。 结论论文通过利用MLLMs的常识推理能力，并设计一系列训练和推理策略，使得模型在广泛的对象类别下具有很强的泛化能力，并在真实世界中展示了良好的表现。实验结果表明，所提出的方法在模拟器和真实世界中均表现出较高的操控成功率。 面向工业的具身智能创新技术研发环境目的：实现复杂场景下的机器人自主分拣，抓取，搬运和精细操作等运动整体研发环境主要由四大部分组成：1.智能机器人模仿学习系统2.自主智能操作系统3.自主操作应用验证系统4.自主操作展示系统 平台整体流程：模仿学习环境–&gt;虚拟训练–&gt;智能机器人自主操作 模仿学习：通过人类的示范操作生成了大量的训练数据样本，让机器人能够通过感知系统捕捉观察人类的动作。虚拟训练：基于海量的机械臂模仿学习数据集，机器人在虚拟训练平台上进行大规模的虚拟训练和测试，大幅提升机器人的训练效率智能机器人自主操作：机器人准确认识别复杂的三维工作场景，并自主根据环境变化灵活调整策略规划出最优的行动 路径。 (1)双臂模仿学习与遥操作套件 执行机械臂精细操作模仿人类动作自主执行任务 2.视觉系统 提供实时的视觉反馈 3.模仿学习数据采集与验证系统 能够实时的采集和处理遥操作相关的数据与图像信息，并实时演示机械臂的运动信息 能够将机械臂模仿学习的数据导入到虚拟仿真平台中进行训练 能够将已有的控制算法和仿真平台中的训练结果快速的导出和部署在模仿学习系统中，验证机器人的运动控制算法。 模仿学习是什么：抓取模型： SAM-E:利用序列模仿的可视化基础模型进行具身操作目的：在三维操作中获取多任务模仿策略对场景理解和动作预测。目前的方法采用三维表示和多视图二维表示来预测机器人末端执行器的姿态。之前方法的缺点：仍然需要大量高质量的机器人轨迹，并且在看不见的任务中泛化有限，在长视界推理中执行效率低下。SAM-E，这是一种新的机器人操作架构，利用基于视觉的模型同时融合场景理解和并用于长期动作推理的序列模仿。具体而言，我们采用在大量图像和提示蒙版上进行预训练的Segment Anything (SAM)作为提取任务相关特征的基础模型，并对机器人数据采用参数高效微调以更好地理解具体场景。优点：SAM-E算法的性能好执行效率高，并且在小镜头适应新任务方面的泛化能力也有显著提高。SAM的两个核心：(1)利用具有提示驱动架构和强大泛化能力的可视化基础模型SAM来处理具体化场景中的语言提示(指示)任务;(2)利用动作的时间平滑特性对动作进行序列建模，提高连贯的规划和执行效率。经过测试：SAM- e (SAM→DINO)在从零开始训练方面不如SAME (SAM→R3M)，但在自适应方面表现更好，在更一般的图像数据中表现出更强的预训练表征的泛化能力。SAM-E在多任务操作上优于现有的先进模型，在执行效率和少镜头自适应方面有了显著提高，并且具有很强的泛化能力 什么是模仿学习：基本思想是让机器通过观察和模仿人类或其他智能体的行为来学习任务。这种方法的目标是使机器能够在未知环境中执行复杂的任务，而无需显式地对环境进行建模或使用传统的强化学习方法。 它在需要快速获取基本技能或模式的情况下表现良好，特别是在有明确的示范或专家数据可用的情况下。智能控制：更适合处理复杂、动态和不确定的环境。智能控制系统能够通过实时的数据分析和反馈，调整和优化控制策略，以适应变化的环境和任务需求。 模仿学习和智能控制： 模仿学习与智能控制结合： 在一些复杂的控制任务中，可以结合模仿学习和智能控制的方法。例如，使用模仿学习从专家示范中学习基本技能和策略，然后结合智能控制技术在实时环境中优化和调整这些策略。这种结合可以提高系统的学习效率和实时响应能力。 例子： 自动驾驶汽车的开发可以是一个典型例子。车辆可以通过模仿学习从人类驾驶员的行为中学习基本的驾驶技能和规则。随着时间的推移和实时环境的变化，智能控制系统则可以根据传感器数据实时调整车辆的控制策略，以应对复杂的交通情况和道路条件。 它们可以相互结合，以达到更高效、更智能的控制和学习目标。模仿学习的优点：减少训练时间和成本快速学习复杂任务适用性广泛：模仿学习的应用领域非常广泛，涵盖了机器人学、自动驾驶、游戏策略学习等多个领域。 任意抓取和操作具有各种几何和物理特性的任意物体是人形双臂机器人系统通用化的技术体现，构建一个通用的感知-规划-控制架构有望能利用双臂系统硬件本体能力并充分发挥其灵巧性和多功能性的特点，弥合AI技术与机器人技术间的鸿沟。 双臂通用协同灵巧操作架构，该架构在感知层、双手抓取、协同操作规划和底层控制等方面提供了丰富的接口，具有很高的通用性、可扩展性和兼容性。![[Pasted image 20240822114420.png]] 灵巧-可达感知双臂抓取子架构，实现视觉系统感知到的物体3D点云到灵巧-可达最优的双臂6D抓取位姿对之间的端到端映射。数据集包含6327个物体的Mesh和超过900万组抓取对，每一组抓取都采用抓取奇异性-抓取稳定性-抓取力兼容性三个指标做了标注![[Pasted image 20240822114446.png]]","categories":[{"name":"文献阅读","slug":"文献阅读","permalink":"http://example.com/categories/%E6%96%87%E7%8C%AE%E9%98%85%E8%AF%BB/"}],"tags":[{"name":"机器人 文献阅读","slug":"机器人-文献阅读","permalink":"http://example.com/tags/%E6%9C%BA%E5%99%A8%E4%BA%BA-%E6%96%87%E7%8C%AE%E9%98%85%E8%AF%BB/"}]},{"title":"git学习","slug":"git","date":"2025-01-08T08:17:55.000Z","updated":"2025-01-08T08:19:49.232Z","comments":false,"path":"2025/01/08/git/","permalink":"http://example.com/2025/01/08/git/","excerpt":"","text":"git是什么Git 是一个免费的、开源的分布式版本控制系统，可以快速高效地处理从小型到大型的各种项目。 版本控制：可以记录文件修改历史记录，从而让用户能够查看历史版本，方便版本切换。 分布式：![[Pasted image 20240317203212.png|300]]首先，分布式版本控制系统根本没有“中央服务器”，每个人的电脑上都是一个完整的版本库，这 样，你工作的时候，就不需要联网了，因为版本库就在你自己的电脑上。既然每个人电脑上都有一 个完整的版本库，那多个人如何协作呢？比方说你在自己电脑上改了文件A，你的同事也在他的电脑 上改了文件A，这时，你们俩之间只需把各自的修改推送给对方，就可以互相看到对方的修改了。 集中式： ![[Pasted image 20240317200249.png|300]]版本库是集中存放在中央服务器的，而干活的时候，用的都是自己的电脑，所以要先从中央服务器 取得最新的版本，然后开始干活，干完活了，再把自己的活推送给中央服务器。CVS CVS 作为最早的开源而且免费的集中式版本控制系统，直到现在还有不少人在用。但由于 CVS 自身设计的问题，会造成提交文件不完整，版本库莫名其妙损坏的情况。 SVN 同样是开源而且免费的 SVN 修正了 CVS 的一些稳定性问题，是目前用得最多的集中式版本库控制系统。原文链接：https://blog.csdn.net/qq_40395874/article/details/116486027 中央服务器就好比是一个图书馆，你要改一本书，必须先从图书馆借出来，然后回到家自己改， 改完了，再放回图书馆。 弊端： 必须联网才能工作，如果在局域网内还好，带宽够大，速度够快，可如果在互联网上，遇到网速慢的话，可能提交一个10M的文件就需要5分钟 为什么要用版本控制工具 实际项目开发中，总是需要将源码拷贝多份，以满足不同的需求。例如，每发布一个版本，就需要复制一份来存档当前版本的源码。 实际项目开发中，基本都是多个人合作完成，在多个人写代码时，就牵扯到代码合并成一份的问题。 在 Linux 开源的初期，Linux 开源项目的代码是 linus 本人通过 linux 命令 diff 和 patch 两条命令手动完成。随着 Linux 代码越来越壮大，靠 Linus 一个人来手动合并已经不现实。 2002 年，Linus 选择了一个商业版本控制系统 BitKeeper 作为 Linux 内核的代码管理工具（BitKeeper 的开发商 BitMover 授权 linux 社区免费使用）。但是，免费使用是有很多的限制的，因此 linux 社区的大佬开始破解 BitKeeper。其中，samba 的作者 andrew 破解成功了。但是被 BitMover 公司发现，收回免费使用权。迫不得已，Linus 选择了自己开发一个分布式版本控制工具以替代 BitKeeper。传说，Linus 闭关一个月，写出了 Git。此后，Git 成功接管了 Linux 社区的版本控制工作 工作机制![[Pasted image 20240317195056.png|600]] 什么是github?GitHub是一个面向开源及私有软件项目的托管平台，提供了一些社交网络功能，主要为程序员服务。在GitHub上可以发布开源软件、协作编程、管理项目、代码审查、免费托管维基、下载代码等。 Git偏向于版本控制的具体实现，而GitHub则扮演了一个集成了Git的版本控制和社交化代码托管平台的角色。Git可以用于本地代码管理，而GitHub用于与他人的代码协作和分享。简单地说，Git是一种工具，而GitHub是Git的一个应用场景。 开源协议开源协议的主要作用是规定了使用和共享开源软件的方式和条件，从而促进了开源软件的发展和应用。保护开发者和使用者的权益。开源协议允许开发者共享源代码，鼓励协作与开放，促进了开源社区的形成和发展，为开发者提供了资源与支持。并且提高了代码的复用性 六种常用的开源协议：![[Pasted image 20240408111910.png]]https://blog.csdn.net/qq_28877125/article/details/116887370?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522171254540616777224427654%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=171254540616777224427654&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-116887370-null-null.142^v100^pc_search_result_base2&amp;utm_term=%E5%BC%80%E6%BA%90%E5%8D%8F%E8%AE%AE&amp;spm=1018.2226.3001.4187 开源协议和GitHub之间具有较强的关联性。开源协议使得开源软件的共享和授权变得合法和有序，而GitHub则为开源协议的实施提供了便利的存储、分享和交流渠道。 gitlabGitLab 是一个用于仓库管理系统的开源项目，使用Git作为代码管理工具，并在此基础上搭建起来的web服务。 git,github,gitlab之间的区别GitHub和GiLlab两个都是基于Web的Git远程仓库，它们都提供了分享开源项目的平台，为开发团队提供了存储、分享、发布和合作开发项目的中心化云存储的场所。gitlab的私密性更好。 ![[Pasted image 20240408131325.png]] git kraken: Git 可视化工具如何安装以及配置环境：https://blog.csdn.net/Ckuanfeng/article/details/127560434如何使用：https://blog.csdn.net/shaobing32/article/details/132314377 正式使用开始学习githttps://blog.csdn.net/weixin_47638941/article/details/120632890?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522171264248116800182787480%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=171264248116800182787480&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-120632890-null-null.142^v100^pc_search_result_base2&amp;utm_term=%E5%A6%82%E4%BD%95%E4%B8%8B%E8%BD%BDgit&amp;spm=1018.2226.3001.4187![[Pasted image 20240409060437.png]] 123git config --global user.name &quot;名称&quot;git config --global user.email &quot;邮箱&quot; 如何配置ssh密钥什么是ssh密钥SSH（Secure Shell）密钥是一种用于加密通信和身份验证的安全协议。在SSH协议中，密钥用于验证客户端和服务器之间的身份，并加密在它们之间传输的数据，从而提供了安全性和保密性。 SSH密钥通常由两部分组成：私钥和公钥。 私钥（Private Key）：私钥是一段保密的数据，存储在客户端的本地计算机上。它是由用户创建并保密的，用于对数据进行加密和签名。私钥通常是一个文件，需要妥善保管，不应该泄露给他人。 公钥（Public Key）：公钥是与私钥配对的非保密数据，可以公开发布。公钥用于解密由私钥加密的数据，或验证由私钥签名的数据的真实性。公钥通常是一个文件，可以被传输到需要访问的服务器上。https://www.runoob.com/git/git-remote-repo.html ![[企业微信截图_1712649531867.png]]如果 12ssh -T git@github.com 失败则https://blog.csdn.net/qq_52293358/article/details/124535927 检查已有的配置环境 1git config --list 1git add 将文件添加到Git的暂存区，准备将其纳入下一次提交。可以指定具体的文件名或使用 . 来添加当前目录下的所有文件 1git status 显示当前仓库的状态，包括已修改但未暂存的文件、已暂存但未提交的文件以及分支信息提供了对当前仓库中文件变更的概览 1git diff 显示当前工作区与暂存区之间的文件差异 1git log 显示当前分支的提交历史。 1git commit -m &quot;[提交消息]&quot; 提交暂存区的文件到Git仓库，并创建一个新的提交记录。 1git push &lt;远程主机名&gt; &lt;本地分支名&gt;:&lt;远程分支名&gt; https://blog.csdn.net/loongkingwhat/article/details/84378386?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522171265457416777224485607%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=171265457416777224485607&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-84378386-null-null.142^v100^pc_search_result_base2&amp;utm_term=%20git%20push&amp;spm=1018.2226.3001.4187如何push到所需要的仓库 123git remote add origin https://github.com/allencat0712/sncgittry.git git branch -M main git push -u origin main ![[Pasted image 20240409195346.png]]","categories":[{"name":"git","slug":"git","permalink":"http://example.com/categories/git/"}],"tags":[{"name":"git","slug":"git","permalink":"http://example.com/tags/git/"}]},{"title":"数据库学习","slug":"数据库学习","date":"2025-01-08T07:15:10.000Z","updated":"2025-01-08T09:52:53.089Z","comments":false,"path":"2025/01/08/数据库学习/","permalink":"http://example.com/2025/01/08/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%A6%E4%B9%A0/","excerpt":"","text":"数据库SQL：DDL查询所有数据库：注意databases 1SHOW DATABASES; 查询当前数据库： 1SELECT DATABASE(); 创建数据库: 1CREATE DATABASE[数据库名][字符集][排列规则]; 如果重复执行时会报错，数据库已经存在就不能重复存在建字符串类型的时候用varchar 后面必须加()注明长度删除数据库： 1DROP DATABASE [数据库名]; 使用数据库：USE 数据库 DDL-表操作-查询查询当前数据库中的所有表： 1SHOW TABLES; 查询表结构： 1DESC 表名; 查询指定表的建表语句 1SHOW CREATE TABLE 表名; DDL-表操作-数据类型数值类型 TINYINT SMALLINT 类似于short INT 0～4294967295 BIGINT 0～2^64-1 FLOAT 单精度浮点数 DOUBLE 双精度浮点数 score double(4,1)表示一个double类型，整体长度是4,小数部分的 长度为1位 DECIMAL文本类型 CHAR 定长字符串 性能高 VARCHAR 变长字符串 性能较差 TEXT 长文本数据 BLOB 二进制形式的长文本数据日期类型 DATE 日期值 TIME 时间值 YEAR 年份 DATETIME 混合日期和时间值 DDL-表操作-修改添加字段： 1ALTER TABLE 表名 字段名 类型（长度）; 修改字段修改数据类型 1ALTER TABLE 表名 MODIFY 字段名 新数据类型; 修改字段名和字段类型 1ALTER TABELE 表名 CHANGE 旧字段名 新字段名 类型; 删除字段： 1ALTER TABLE 表名 DROP 字段名; 修改表名： 1ALTER TABLE 表名 RENAME TO 新表名; 删除指定表，并重新创建，重置该表： 1TRUNCATE TABLE 表名; DML-增-删-改DML-添加数据-insert1INSERT INTO 表名（字段1,字段2）VALUES（值1,值2）; 字段1对应值1,如果要进行多个值同时插入，（）间用,分割。 DML-修改数据-updata1UPDATE 表名 SET 字段名=值1,字段名2=值2,……[WHERE 条件] 条件比如说id&#x3D;1,也就是id为1的数据进行修改 DML删除数据1DELETE FROM 表名 [WHERE 条件] 注意：DELETE中语句的条件可以有也可以没有，如果没有条件，则会删除整张表的所有数据不可以删除某一个字段的值 DQL-数据查询语言关键字-SELECT可以分为以下部分： 1.基础查询1SELECT 字段1, 字段2, 字段3 ... FROM 表名 ; 去除重复记录： 1SELECT DISTINCT 字段列表 FROM 表名; 2.条件查询1SELECT 字段列表 FROM 表名 WHERE 条件列表 ; 比较运算符&lt; &gt; &#x3D; &lt;&#x3D; &gt;&#x3D; !&#x3D; IS NULL LIKE(占位符）逻辑运算符AND OR NOTeg: 1234select * from emp where age between 15 and 20;select * from emp where gender = &#x27;女&#x27; and age &lt; 25;select * from emp where age in(18,20,40);select * from emp where idcard like &#x27;_________________X&#x27;;//查询身份证号最后一位是X的员工信息 3.聚合函数将一列数据作为一个整体，进行纵向计算 1SELECT 聚合函数(字段列表) FROM 表名 ; 常见的聚合函数：count（统计数量） max min avg(平均数） sum 1select max(age) from emp; 4.分组查询1SELECT 字段列表 FROM 表名 [ WHERE 条件 ] GROUP BY 分组字段名 [ HAVING 分组后过滤条件 ]; where与having区别 执行时机不同： where是分组之前进行过滤，不满足where条件，不参与分组；而having是分组 之后对结果进行过滤。 判断条件不同： where不能对聚合函数进行判断，而having可以。 查询年龄小于45的员工 , 并根据工作地址分组 , 获取员工数量大于等于3的工作地址 12select workaddress, count(*) address_count from emp where age &lt; 45 group byworkaddress having address_count &gt;= 3; 5.排序查询-order by1SELECT 字段列表 FROM 表名 ORDER BY 字段1 排序方式1 , 字段2 排序方式2 ; ASC 升序 DESC 降序 12select * from emp order by age asc;select * from emp order by age; 6.分页查询1SELECT 字段列表 FROM 表名 LIMIT 起始索引, 查询记录数 ; eg: 12select * from emp limit 0,10;select * from emp limit 10; 编写顺序select –&gt;字段列表–&gt;from –&gt;表名列表 –&gt;where –&gt;条件列表–&gt;group by–&gt;分组字段列表–&gt; having–&gt;分组后条件列表–&gt;order by –&gt;排序字段列表–&gt;limit –&gt;分页参数 eg: 12345select tmp.t1 person1,tmp.t2 person2,count(*) call_count,sum(tmp.duration) total_durationfrom (select if(from_id&gt;to_id,to_id,from_id) t1,if(from_id&gt;to_id,from_id,to_id) t2,duration from calls) tmpgroup by tmp.t1,tmp.t2 tmp.t1是一个临时的分组，表示的是一列，新表的一列，然而person1是这列的名字，相当于t1是这个新表名叫person1这列的一个指针，指向的是person1这列的内容而if(from_id&gt;to_id,to_id,from_id） 是一个条件的判断，是指如果from_id&gt;to_id,则返回to_id,若为假则返回from_id DCL-数据控制语言可以控制数据库可以由谁访问以及谁可以访问哪些数据库 用户管理权限控制函数字符串函数：Mysql函数大全字符串函数：链接，转换，去除空格，截取等数值函数，日期函数，流程函数 约束目的：保证数据库中数据的正确性，有效性，完整性分类：非空约束 NOT NULL唯一约束： UNIQUE unique主键约束：PRIMARY KEY primary key默认约束：DEFAULT default外键约束：FOREIGN KEY foreign key检查约束：CHECK check可以完成表结构的创建 ：字段名 数据类型 约束关键字外键约束：让两张表之间建立链接，从而保证一致性和完整性，外键是’某个表 A’中的’一列 column’,它包含在’另一个表 B’的’主键’中格式： 1alter table emp add constraint fk_emp_dept_id foreign key (dept_id) reference dept(id); 这条语句的作用是在 emp 表上添加一个名为 fk_emp_dept_id 的外键约束，该外键约束基于 emp 表中的 dept_id 列，并指向 dept 表中的 id 列。 多表关系一对多 在多的表中一列建立外键约束多对多 建立第三张中间表，中间至少包含两个外键，分别关联两方主键一对一 将表拆分为多表，并设置唯一外键 多表查询：需要消除无效的笛卡尔积连接查询：内连接 外连接 1234select sname from s where not exists(select * from scWhere sno=s.sno and cno=&#x27;002&#x27;) 所有不存在这条记录的学生被返回 unique index 唯一索引binary column 1234567891011SUM(score_points) OVER (PARTITION BY gender ORDER BY day) 是 SQL 中窗口函数的用法，它结合了聚合函数和窗口函数的概念。下面是它的作用和用法的分解：语法解析SUM(score_points):是一个聚合函数，用于计算 score_points 列的累积和。OVER 子句:定义了窗口范围，即在哪些数据行上应用聚合函数。PARTITION BY gender:将数据按 gender 列分组（类似于 GROUP BY，但不会减少结果行数）。每个 gender 的分组内分别计算。ORDER BY day:指定窗口内的行按 day 列排序，从而实现有序累加。","categories":[{"name":"数据库","slug":"数据库","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}]},{"title":"Hello World","slug":"hello-world","date":"2025-01-02T09:09:11.980Z","updated":"2025-01-02T09:09:11.981Z","comments":true,"path":"2025/01/02/hello-world/","permalink":"http://example.com/2025/01/02/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[{"name":"文献阅读","slug":"文献阅读","permalink":"http://example.com/categories/%E6%96%87%E7%8C%AE%E9%98%85%E8%AF%BB/"},{"name":"git","slug":"git","permalink":"http://example.com/categories/git/"},{"name":"数据库","slug":"数据库","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"机器人 文献阅读","slug":"机器人-文献阅读","permalink":"http://example.com/tags/%E6%9C%BA%E5%99%A8%E4%BA%BA-%E6%96%87%E7%8C%AE%E9%98%85%E8%AF%BB/"},{"name":"git","slug":"git","permalink":"http://example.com/tags/git/"},{"name":"数据库","slug":"数据库","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}]}